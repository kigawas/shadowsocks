{
  "name": "Shadowsocks-learning",
  "tagline": "Shadowsocks with comments which are helpful to understand its structure.",
  "body": "shadowsocks-learning\r\n===========\r\n\r\nShadowsocks with comments which are helpful to understand its structure.\r\n\r\nThis repository should only be used for learning Python.\r\n\r\n## Project structure\r\n\r\n1. `asyncdns.py`: Handling DNS requests.\r\n\r\n2. `common.py`: Wrapping some functions to make them easier to use.\r\n  - `ord`, `chr` to convert between `int` and `char` just like C. The default `ord` and `chr` functions in Python have been replaced.\r\n  - `socket.inet_pton`, `socket.inet_ntop` to convert IP string and network bytes. If `socket` does not have the two functions (e.g. Before Python 2.3), the author implemented them.\r\n\r\n  > Notice that `socket.inet_pton` can handle IPV4 and IPV6 addresses, yet `socket.inet_aton` cannot handle IPV6.\r\n\r\n  - `parse_header`, `pack_addr` network utility functions.\r\n  - `IPNetwork` class which saves IP addresses with prefixes.\r\n\r\n3. `daemon.py`: Make Shadowsocks run as a daemon in \\*NIX.\r\n\r\n4. `encrypt.py`: Encrypt/Decrypt Shadowsocks's protocol to circumvent the firewall.\r\n\r\n5. `eventloop.py`: Use `select`,`epoll`, `kqueue` to multiplex I/O\r\n\r\n6. `local.py`: Client code using SOCKS to set up a proxy and transfer packets.\r\n\r\n7. `lru_cache.py`: LRU cache for DNS caching in `asyncdns.py`.\r\n\r\n8. `manager.py`: A config manager.\r\n\r\n9. `server.py`: Server code requesting remote sites and sending back responses to clients.\r\n\r\n10. `shell.py`: Prompting and handling configs in shell.\r\n\r\n11. `tcprelay.py`: Connecting remote servers by TCP.\r\n\r\n12. `udprelay.py`: Connecting remote servers by UDP.\r\n\r\nThe core modules are `asyncdns.py`, `eventloop.py`, `tcprelay.py`, and `udprelay.py`. `local.py` and `server.py` are just wrapping them up.\r\n\r\n## Evolution of Shadowsocks\r\n\r\nAt first, Shadowsocks only uses [*substitution cypher*](https://en.wikipedia.org/wiki/Substitution_cipher) to cypher the packets, which is thought to be very **unsafe**. In addition, in the early version of Shadowsocks, there are only 2 core modules: `local.py` and `server.py`. Due to its concision, we take [this](https://github.com/kigawas/shadowsocks-learning/tree/8c5c40915ea8fbd22a0f1a6a9596010565118b35) version as an example to explain the underground mechanism of Shadowsocks.\r\n\r\n### Local module in early version\r\nFirstly, we check the `local.py`.\r\nWe can see the author build a table to make substitutions of ASCII characters.\r\n```python\r\ndef get_table(key):\r\n    m = hashlib.md5()\r\n    m.update(key)\r\n    s = m.digest()\r\n    (a, b) = struct.unpack('<QQ', s)#here we can get 2 unsigned long long integers\r\n    table = [c for c in string.maketrans('', '')]\r\n    for i in xrange(1, 1024):\r\n        table.sort(lambda x, y: int(a % (ord(x) + i) - a % (ord(y) + i)))\r\n    return table\r\n```\r\n\r\nThen comes a TCP Server with multi-threading. You can find a usage at [here](https://docs.python.org/2/library/socketserver.html#asynchronous-mixins).\r\n```python\r\nclass ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\r\n    pass\r\n```\r\n\r\nNow we can see the core class of `local.py`, it implemented a SOCKS5 server and transfer packets following SOCKS5 protocol. Let's take a glance at it.\r\n```python\r\nclass Socks5Server(SocketServer.StreamRequestHandler):\r\n    def handle_tcp(self, sock, remote):\r\n        try:\r\n            fdset = [sock, remote]\r\n            while True:\r\n                r, w, e = select.select(fdset, [], [])\r\n                if sock in r:\r\n                    data = sock.recv(4096) #recv data from browser\r\n                    if len(data) <= 0:#add len to fix bug\r\n                        break\r\n                    if remote.sendall(self.encrypt(data)) is not None:\r\n                        #encrypt and send them all\r\n                        #to remote SS server\r\n                        break\r\n                if remote in r:\r\n                    data = remote.recv(4096) #recv data from remote SS server\r\n                    if len(data) <= 0:#add len to fix bug\r\n                        break\r\n                    if sock.sendall(self.decrypt(data)) is not None:\r\n                        #decrypt and send them all\r\n                        #to browser\r\n                        break\r\n        finally:\r\n            sock.close()\r\n            remote.close()\r\n```\r\nIn this function, the author uses `select` to support I/O multiplexing. `select.select`'s [signature](https://docs.python.org/2/library/select.html#select.select) is `select.select(rlist, wlist, xlist[, timeout])`, here our server just need to use `rlist` to wait until ready for reading `sock` and `remote`. The `sock` connects user's web browser as a proxy and the `remote` connects a shadowsocks server which is located beyond the firewall.\r\n\r\nThen comes functions related to ciphering and deciphering. The author uses [`string.translate`](https://docs.python.org/2/library/string.html#string.translate) to encrypt and decrypt data. Notice that it is very **unsafe** to do so. You can find more information about cryptography on [Wikipedia](https://en.wikipedia.org/wiki/Cryptography#Modern_cryptography).\r\n```python\r\ndef encrypt(self, data):\r\n    return data.translate(encrypt_table)\r\n\r\ndef decrypt(self, data):\r\n    return data.translate(decrypt_table)\r\n\r\ndef send_encrypt(self, sock, data):\r\n    sock.send(self.encrypt(data))\r\n```\r\n\r\nThe last function in class `Socks5Server` comes at last!:laughing: It is also the longest function and  seems to be a little frustrating.:open_mouth:\r\n```python\r\ndef handle(self):\r\n    try:\r\n        data = self.rfile.read(2)\r\n        self.rfile.read(ord(data[1]))\r\n        self.wfile.write(\"\\x05\\x00\")\r\n        data = self.rfile.read(4)\r\n        mode = ord(data[1])\r\n        if mode != 1:\r\n            logging.warn('mode != 1')\r\n            return\r\n        addrtype = ord(data[3])\r\n        addr_to_send = data[3]\r\n        if addrtype == 1:#IPV4 address\r\n            addr_ip = self.rfile.read(4)#read IP\r\n            addr = socket.inet_ntoa(addr_ip)#convert it to a string like \"192.168.0.1\"\r\n            addr_to_send += addr_ip\r\n        elif addrtype == 3:#domain name\r\n            addr_len = self.rfile.read(1)#read length\r\n            addr = self.rfile.read(ord(addr_len))#read domain name\r\n            addr_to_send += addr_len + addr\r\n        else:\r\n            logging.warn('addr_type not support')\r\n            # not support\r\n            return\r\n        addr_port = self.rfile.read(2)#read port\r\n        addr_to_send += addr_port#ATYP + dest IP + port or ATYP + length + domain name + port\r\n        port = struct.unpack('>H', addr_port)#convert unsigned short bytes to (port,) in Python\r\n        try:\r\n            reply = \"\\x05\\x00\\x00\\x01\"#VER REP RSV ATYP\r\n            reply += socket.inet_aton('0.0.0.0') + struct.pack(\">H\", 0)#binding 0.0.0.0\r\n            self.wfile.write(reply)\r\n            # reply immediately\r\n            if '-6' in sys.argv[1:]:\r\n                remote = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\r\n            else:\r\n                remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            remote.connect((SERVER, REMOTE_PORT))\r\n            self.send_encrypt(remote, addr_to_send)\r\n            logging.info('connecting %s:%d' % (addr, port[0]))\r\n        except socket.error, e:\r\n            logging.warn(e)\r\n            return\r\n        self.handle_tcp(self.connection, remote)\r\n    except socket.error, e:\r\n        logging.warn(e)\r\n```\r\nBecause `Socks5Server` inherits [`SocketServer.StreamRequestHandler`](https://docs.python.org/2/library/socketserver.html#SocketServer.StreamRequestHandler), the function `handle` must be overridden to handle requests from clients which are thought to be users' browsers.\r\nAt the first two lines, our SOCKS5 server receive a connecting request from a client. You can find the protocol at [RFC1928](https://www.ietf.org/rfc/rfc1928.txt).\r\n\r\nAt the first two lines:\r\n```python\r\ndata = self.rfile.read(2)\r\nself.rfile.read(ord(data[1]))\r\n```\r\nThey read data from client like:\r\n\r\n| VER | NMETHODS | METHODS |\r\n| --- | -------- | ------- |\r\n|  1  |     1    |  1-255  |\r\n\r\n- VER means SOCKS version, here should be 0x05\r\n- NMETHODS is the length of METHODS\r\n- METHODS is a list of verifications. 0x00 means no verifications.\r\n\r\nAfter the server received the request, the code `self.wfile.write(\"\\x05\\x00\")` responds like:\r\n\r\n| VER | METHODS |\r\n| --- | ------- |\r\n|  1  |    1    |\r\n\r\n- VER should be 0x05\r\n- METHODS should be 0x00 without verifications.\r\n\r\nAfter the handshaking stage, the client can send requests to our server. The request format is:\r\n\r\n| VER | CMD | RSV  | ATYP | DST ADDR | DST PORT |\r\n|-----|-----|------|------|----------|----------|\r\n| 1   | 1   | 0x00 | 1    | Variable | 2        |\r\n\r\n- VER means SOCKS version, here should be 0x05\r\n- CMD means command\r\n  - 0x01: CONNECT\r\n  - 0x02: BIND\r\n  - 0x03: UDP forwarding\r\n- RSV means reserved, now it is 0x00\r\n- ATYPE means address type\r\n  - 0x01: IPV4 address, DST ADDR will be 4 bytes\r\n  - 0x03: domain name, the first byte in DST ADDR indicates the length, and the rest will be the domain name (without \\\\0)\r\n  - 0x04: IPV6 address, DST ADDR will be 16 bytes\r\n- DST ADDR means destination address\r\n- DST PORT means destination port\r\n\r\nThen,\r\n```python\r\nreply = \"\\x05\\x00\\x00\\x01\"#VER REP RSV ATYP\r\nreply += socket.inet_aton('0.0.0.0') + struct.pack(\">H\", 0)#binding 0.0.0.0\r\nself.wfile.write(reply)\r\n```\r\nNow our server replies to user's browser.\r\nCorrespondingly, the server's response format is:\r\n\r\n| VER | REP | RSV  | ATYP | BND ADDR | BND PORT |\r\n|-----|-----|------|------|----------|----------|\r\n| 1   | 1   | 0x00 | 1    | Variable | 2        |\r\n\r\n- VER means SOCKS version, here should be 0x05\r\n- REP means reply\r\n  - 0x00: succeeded\r\n- RSV means reserved, now it is 0x00\r\n- ATYPE means address type\r\n  - 0x01: IPV4 address, DST ADDR will be 4 bytes\r\n  - 0x03: domain name, the first byte in DST ADDR indicates the length, and the rest will be the domain name (without \\0)\r\n  - 0x04: IPV6 address, DST ADDR will be 16 bytes\r\n- BND ADDR means bound address\r\n- BND PORT means bound port\r\n\r\n### Server module in early version\r\n\r\nJust like `local.py`, `server.py` also follows the same structure. The function `get_table` and class `ThreadingTCPServer` are nothing different. And `Socks5Server` is even simpler than its local version due to there is no need to handle SOCKS5 protocol. Check out the comments!:laughing:\r\n```python\r\nclass Socks5Server(SocketServer.StreamRequestHandler):\r\n    def handle_tcp(self, sock, remote):\r\n        try:\r\n            fdset = [sock, remote]\r\n            while True:\r\n                r, w, e = select.select(fdset, [], [])\r\n                if sock in r:#recv data from local\r\n                    data = sock.recv(4096)\r\n                    if len(data) <= 0:\r\n                        break\r\n                    if remote.sendall(self.decrypt(data)) is not None:\r\n                        #we need to decrypt them\r\n                        #and send them to destination server (e.g. google.com)\r\n                        break\r\n                if remote in r:#recv data from destination server\r\n                    data = remote.recv(4096)\r\n                    if len(data) <= 0:\r\n                        break\r\n                    if sock.sendall(self.encrypt(data)) is not None:\r\n                        #we need to encrypt them to circumvent the firewall\r\n                        #and send them back to local\r\n                        break\r\n        finally:\r\n            sock.close()\r\n            remote.close()\r\n\r\n    def encrypt(self, data):\r\n        return data.translate(encrypt_table)\r\n\r\n    def decrypt(self, data):\r\n        return data.translate(decrypt_table)\r\n\r\n    def handle(self):\r\n        try:\r\n            sock = self.connection\r\n            #as mentioned before, the address is like\r\n            #ATYP + dest IP + port or ATYP + length + domain name + port\r\n            addrtype = ord(self.decrypt(sock.recv(1)))\r\n            if addrtype == 1:#dest IP + port\r\n                addr = socket.inet_ntoa(self.decrypt(self.rfile.read(4)))\r\n            elif addrtype == 3:#length + domain name + port\r\n                addr = self.decrypt(\r\n                    self.rfile.read(ord(self.decrypt(sock.recv(1)))))\r\n            else:\r\n                # not support\r\n                logging.warn('addr_type not support')\r\n                return\r\n            port = struct.unpack('>H', self.decrypt(self.rfile.read(2)))\r\n            try:\r\n                logging.info('connecting %s:%d' % (addr, port[0]))\r\n                remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n                remote.connect((addr, port[0]))\r\n            except socket.error, e:\r\n                # Connection refused\r\n                logging.warn(e)\r\n                return\r\n            self.handle_tcp(sock, remote)\r\n        except socket.error, e:\r\n            logging.warn(e)\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}